package io.spine.publishing.github

import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import com.google.api.client.http.HttpRequest
import com.google.common.net.HttpHeaders
import com.google.common.net.HttpHeaders.AUTHORIZATION
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.openssl.PEMParser
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter
import java.io.FileReader
import java.nio.file.Path
import java.security.KeyPair
import java.security.PrivateKey
import java.security.Security
import java.security.interfaces.RSAPrivateKey
import java.time.Instant.now
import java.time.temporal.ChronoUnit.MINUTES
import java.util.*

/**
 * A JWT that can be used to authorize [GitHubApiRequest]s.
 *
 * GitHub JWTs have an expiration time, see [SignedJwts]. After the JWT has expired,
 * it may be [refreshed][refresh].
 *
 * @param stringValue the string value of the JWT
 * @param refreshTokenFn a function that refreshes the value of the JWT
 */
data class GitHubJwt(private val stringValue: String,
                     private val refreshTokenFn: () -> GitHubJwt) {
    /**
     * Returns a new GitHub JWT.
     *
     * Use when this JWT reaches its expiration time.
     */
    fun refresh(): GitHubJwt = refreshTokenFn()

    /**
     * Authorizes the specified request by setting it's `AUTHORIZATION` header to this JWT.
     *
     * Most of the GitHub REST API requests must be authorized. Check with the GitHub
     * [documentation](https://docs.github.com/en/rest) for whether a particular request must be
     * authorized with a JWT.
     */
    fun authorizeRequest(request: HttpRequest) {
        request.headers[AUTHORIZATION] = "Bearer $stringValue"
    }
}

/**
 * A factory of JWTs that can authorize GitHub API requests.
 */
interface JwtFactory {

    /**
     * Generates a new GitHub JWT.
     */
    fun jwtFor(app: GitHubApp): GitHubJwt
}

/**
 * A factory of JWTs that generates and signs them based on a
 * [locally stored private key][privateKeyPath].
 *
 * JWTs that are generated by this factory expire after 10 minutes, as it is the maximum
 * lifetime allowed by GitHub.
 */
class SignedJwts(private val privateKeyPath: Path) : JwtFactory {

    /**
     * Generates a GitHub JWT, signing it using a private key from  a `.pem` file
     * located by the specified path.
     *
     * The JWT created by this method expires in 10 minutes. After expiration, it no longer
     * can authorize [GitHubApiRequest]s.
     */
    override fun jwtFor(app: GitHubApp): GitHubJwt {
        val path = privateKeyPath
        val appId = app.id
        val jwt = generateJwt(path, appId)
        return GitHubJwt(jwt) { jwtFor(app) }
    }

    private fun generateJwt(privateKeyPath: Path,
                            gitHubAppId: AppId): String {

        Security.addProvider(BouncyCastleProvider())
        val pemParser = PEMParser(FileReader(privateKeyPath.toFile()))
        val converter = JcaPEMKeyConverter().setProvider("BC")

        val pemObject: Any = pemParser.readObject()
        val keyPair: KeyPair = converter.getKeyPair(pemObject as PEMKeyPair)
        val privateKey: PrivateKey = keyPair.private

        val now = now()
        val expirationTime = now.plus(10, MINUTES)
        return JWT.create()
                .withIssuer(gitHubAppId)
                .withIssuedAt(Date.from(now))
                .withExpiresAt(Date.from(expirationTime))
                // We only have the private key from the GitHub App.
                .sign(Algorithm.RSA256(null, privateKey as RSAPrivateKey))
    }
}
