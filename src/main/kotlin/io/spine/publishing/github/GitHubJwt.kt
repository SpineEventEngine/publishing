package io.spine.publishing.github

import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.openssl.PEMParser
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter
import java.io.FileReader
import java.nio.file.Path
import java.security.KeyPair
import java.security.PrivateKey
import java.security.Security
import java.security.interfaces.RSAPrivateKey
import java.time.Instant.now
import java.time.temporal.ChronoUnit.MINUTES
import java.util.*

/**
 * A factory of JWTs that can authorize GitHub API requests.
 */
interface JwtFactory {

    /**
     * Generates a new GitHub JWT.
     */
    fun newJwt(): GitHubJwt
}

/**
 * A JWT that can be used to authorize [GitHubApiRequest]s.
 *
 * GitHub JWTs have an expiration time, see [SignedJwts]. After the JWT has expired,
 * it may be [refreshed][refresh].
 *
 * A JWT must be placed in the "Authorization" header.
 *
 * @param stringValue the string value of the JWT
 * @param refreshTokenFn a function that refreshes the value of the JWT
 */
data class GitHubJwt(private var stringValue: String,
                     private val refreshTokenFn: () -> String) {

    /** Returns the string value of this JWT. */
    val value get() = stringValue

    /**
     * Refreshes the JWT.
     *
     * If the JWT has expired, refreshing it makes the JWT usable again.
     */
    fun refresh() {
        this.stringValue = refreshTokenFn()
    }
}


/** The ID of the GitHub App. */
typealias AppId = String

/**
 * A factory of JWTs that generates and signs them based on a
 * [locally stored private key][privateKeyPath].
 *
 * JWTs that are generated by this factory expire after 10 minutes, as it is the maximum
 * lifetime allowed by GitHub.
 */
class SignedJwts(private val privateKeyPath: Path, private val gitHubAppId: AppId) : JwtFactory {

    /**
     * Generates a GitHub JWT, signing it using a private key from  a `.pem` file
     * located by the specified path.
     *
     * The JWT created by this method expires in 10 minutes. After expiration, it no longer
     * can authorize [GitHubApiRequest]s.
     */
    override fun newJwt(): GitHubJwt {
        val path = privateKeyPath
        val appId = gitHubAppId
        val jwt = generateJwt(path, appId)
        return GitHubJwt(jwt) { generateJwt(path, appId) }
    }

    private fun generateJwt(privateKeyPath: Path,
                            gitHubAppId: AppId): String {

        Security.addProvider(BouncyCastleProvider())
        val pemParser = PEMParser(FileReader(privateKeyPath.toFile()))
        val converter = JcaPEMKeyConverter().setProvider("BC")

        val pemObject: Any = pemParser.readObject()
        val keyPair: KeyPair = converter.getKeyPair(pemObject as PEMKeyPair)
        val privateKey: PrivateKey = keyPair.private

        val now = now()
        val expirationTime = now.plus(10, MINUTES)
        val jwt = JWT.create()
                .withIssuer(gitHubAppId)
                .withIssuedAt(Date.from(now))
                .withExpiresAt(Date.from(expirationTime))
                // We only have the private key from the GitHub App.
                .sign(Algorithm.RSA256(null, privateKey as RSAPrivateKey))
        return jwt
    }
}
